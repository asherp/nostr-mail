{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#nostr-mail","title":"nostr-mail","text":"<p>A simple email encryption tool based on secp256k1 key pairs.</p> <p>How it works:</p> <p>Nostr-mail encrypts content using a symmetric key derived from a combination of the sender's private key and the receiver's public key.</p> <p>Both sender and receiver derive a shared secret known only to them, which is used to protect their communications.</p> <p>This application can use any email server for delivery.</p>"},{"location":"#why-have-you-done-this","title":"Why have you done this?","text":"<p>Nostr-mail aims to improve privacy for the average person by bridging the gap between nostr and email. The two protocols serve different purposes, but they also solve each other's problems. For example, PGP does exist for email but it has not seen mainstream adoption because it relies on an existing key registry.</p> Feature Nostr Email nostr-mail Social Key Registry PGP Long form content Archival Storage Ubiquitous"},{"location":"#obligatory-warning","title":"Obligatory warning","text":"<p>Nostr-mail uses NIP-04, which has many issues pointed out here. While not perfect, it's better than cleartext emails. </p>"},{"location":"#usage","title":"Usage","text":"<p>You'll need Docker.</p> <p>Clone and navigate to the base of the repo directory, then:</p> <pre><code>docker compose up nostrmail\n</code></pre> <p>Navigate to http://localhost:8050</p> <p>Here are all the services you can run with <code>docker compose up &lt;service name&gt;</code></p> service purpose port nostrmail main dashboard site 8050 alice \"Alice\" dashboard for testing 8051 bob \"Bob\" dashboard for testing 8052 docs documentation site 8000 notebook jupyter notebook for prototyping 8888"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#environment-variables","title":"Environment variables","text":"<p>Create a <code>.env</code> file and place it in the base of this repo to set the defaults for the above containers.</p> <pre><code>NOSTR_PRIV_KEY=&lt;your priv key&gt;\nEMAIL_ADDRESS=&lt;your public email address&gt;\nEMAIL_PASSWORD=&lt;email password&gt;\n\n# email server, assuming gmail\nIMAP_HOST=imap.gmail.com\nIMAP_PORT=2525\nSMTP_HOST=smtp.gmail.com\nSMTP_PORT=587\n\n# this is where we find pub keys for now (should use NIP-02)\nNOSTR_CONTACTS=/nostrmail/address_book.yaml\n\n# the below configuration is for test purposes only\nPRIV_KEY_ALICE=&lt;priv key for alice&gt;\nEMAIL_ADDRESS_ALICE=yourname+alice@gmail.com\nEMAIL_PASSWORD_ALICE=&lt;same email password as above&gt;\n\nPRIV_KEY_BOB=&lt;priv key for bob&gt;\nEMAIL_ADDRESS_BOB=yourname+bob@gmail.com\nEMAIL_PASSWORD_BOB=&lt;same password as above&gt;\n\nNOSTR_MAIL_IMAGE_TAG=&lt;dockerhub_username&gt;/nostr-mail\n</code></pre>"},{"location":"#address-bookrelays","title":"Address book/relays","text":"<p>Create a file in the local directory called <code>address_book.yaml</code> to specify private contacts. Here's an example:</p> <pre><code>contacts:\n  - username: alice\n    pubkey: 12697aa72d2269aa632319d000b0548235d1d385dc16260ca77f704e802b5483\n  - username: bob\n    pubkey: 8619149c5549fa9970c042da77d9d018c7213e83aa49b89c234da9c298ecb941\n  - username: asher\n    pubkey: 86fb0bd1f7edcb17b39e897488f51f1d22ac6bd93aae491fc7cd45c9fb0d4ad8\nrelays:\n  - wss://nostr-pub.wellorder.net\n  - wss://relay.damus.io\n</code></pre>"},{"location":"#email","title":"Email","text":"<p>Configure your email account to allow sending and receiving emails. Here are instructions for Gmail:</p> <ol> <li>Generate an app password (required if using 2-factor auth). See https://support.google.com/accounts/answer/185833?hl=en </li> <li>Set <code>EMAIL_PASSWORD</code> in your <code>.env</code> file as explained above.</li> <li>Open Gmail settings to enable IMAP:<ol> <li>In the top right, click Settings and then See all settings.</li> <li>Click the Forwarding and POP/IMAP tab.</li> <li>In the \"IMAP access\" section, select Enable IMAP.</li> <li>Click Save Changes.</li> </ol> </li> </ol>"},{"location":"NIP/","title":"NIP","text":""},{"location":"NIP/#nip-","title":"NIP-??","text":"<p>This NIP defines the basic requirements that should be implemented by anyone wanting to support email alongside nostr.</p>"},{"location":"NIP/#motivation","title":"Motivation","text":"<p>Email integration enables several features for nostr users that relays alone cannot.</p>"},{"location":"NIP/#long-form-messaging","title":"Long form messaging","text":"<p>Nostr messages are intended to mimic the short form messaging of social media. It is largely up to the relay to determine the length of messages, but attachments and formatting are not supported (other NIPs that address this?). Email can extend nostr's capabilities by providing an out-of-band means of communicating larger messages with attachments, which are more suitable in personal or business contexts.</p>"},{"location":"NIP/#archival-storage","title":"Archival storage","text":"<p>Nostr relays are not required to store DMs permanently. With nostr-mail DMs are replicated (in encrypted form) as the subject of an associated email. Thus, email provides a free backup for any DMs sent or received in this manner, in addition to any longer form content or files intended for long term storage.</p>"},{"location":"NIP/#email-authenticationidentification","title":"Email authentication/identification","text":"<p>While the NIP-05 standard allows nostr profiles to be associated with a user who controls their own domain, this is not the case for the vast majority of users. nostr-mail provides a more accessible way to associate one's identity with a public key, by including their email in the profile. The nostr-mail client setup process should be similar to traditional desktop email clients: simply allow the email server to accept SMTP connections and provide email credentials to the nostr-mail client.</p>"},{"location":"NIP/#email-privacy","title":"Email privacy","text":"<p>While Email PGP has been available in various forms since 1991, despite decades of attempts to educate the public, it has not seen wide adoption. Since all Nostr users have key pairs by default, we can leapfrog the education problems associated with traditional PGP. NIP-04 provides a mechanism for encrypting DMs, and we apply the scheme to encrypt/decrypt email content while linking them to specific Nostr DMs. nostr-mail intends to keep up-to-date with the latest encryption standards for DMs. </p>"},{"location":"NIP/#key-rotation","title":"Key rotation","text":"<p>In the event that a user loses access to their private key, Email provides an out-of-band means of communicating a new one. A more formal key rotation mechanism that utilizes email is outside the scope of this NIP, but we hope to address it further in the future!</p>"},{"location":"NIP/#email-signaling","title":"Email signaling","text":"<p><code>final</code> <code>optional</code> <code>author:asherp</code> <code>author:asherp</code></p> <p>A special <code>email</code> field in the user's profile is all that is required to signal that the user accepts encrypted email.</p> <p>Here is example python code that accomplishes this, using python-nostr</p> <pre><code>from nostr.relay_manager import RelayManager\nfrom nostr.key import PrivateKey\nfrom nostr.filter import Filter, Filters\nfrom nostr.event import Event, EventKind\nimport time\n\ndef publish_profile(priv_key, profile_dict):\n    relay_manager = RelayManager()\n\n    for relay in relays:\n        relay_manager.add_relay(relay)\n    relay_manager.open_connections({\"cert_reqs\": ssl.CERT_NONE}) # NOTE: This disables ssl certificate verification\n    print('waiting 1.5 sec to open')\n    time.sleep(1.5)\n\n    event_profile = Event(priv_key.public_key.hex(),\n                          json.dumps(profile_dict),\n                          kind=EventKind.SET_METADATA)\n    priv_key.sign_event(event_profile)\n\n    # check signature\n    assert event_profile.verify()\n    relay_manager.publish_event(event_profile)\n    print('waiting 1 sec to send')\n    time.sleep(1) # allow the messages to send\n\n    relay_manager.close_connections()\n    return event_profile.signature\n\nalice_profile = dict(display_name='Alice',\n              name='alice',\n              picture='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTV-0rZbgnQcRbDqbk0hHPLHPyHpqLJ8xkriA&amp;usqp=CAU',\n              about='my name is Alice..',\n              email='alice@tld.com')\n</code></pre>"},{"location":"NIP/#dm-replication","title":"DM replication","text":"<p>When an email is sent from a nostr-mail client, two things must occur:</p> <ol> <li>a DM with the encrypted subject of the email should be broadcast to the user's nostr relays</li> <li>the body of the email must be encrypted with the same shared secret.</li> <li>an email with the encrypted subject and body (using the same shared secret) must be sent via the user's SMTP server</li> </ol> <p>It is crucial that the email subject matches the encrypted DM exactly. This allows the receiver to verify that the email came from the same author as the DM - specifically, the author whose private key signed the DM event. Second, it allows the receiver to find the encrypted message on their mail server using the subject. Specifically, the <code>iv</code> string used in the encryption will be unique to that message.</p>"},{"location":"Profiles/","title":"Profiles","text":""},{"location":"Profiles/#profiles","title":"Profiles","text":"<p>Nostr-mail profiles require the <code>email</code> keyword to be available.</p> <p>Profiles may be loaded with the function <code>load_user_profile</code>.</p> <p>To test this, we'll assume Alice's priv key is stored in an environment variable.</p> <pre><code>from nostrmail.callbacks import load_user_profile, get_nostr_pub_key\nimport os\n</code></pre> <pre><code>alice_pub_key_hex = get_nostr_pub_key(os.environ['PRIV_KEY_ALICE'])\nalice_pub_key_hex\n</code></pre> <pre><code>profile = load_user_profile(alice_pub_key_hex)\n</code></pre> <pre><code>profile\n</code></pre> <p>Run the following cell to autoreload modifications to any above imports.</p> <pre><code>%load_ext autoreload\n%autoreload 2\n</code></pre>"},{"location":"Techstack/","title":"Techstack","text":"<p>Let's walk through the building blocks of nostr-mail. In addition to explaining how our implementation works, this should serve to illustrate how a similar strategy could be used for other platforms.</p>"},{"location":"Techstack/#dependencies","title":"Dependencies","text":""},{"location":"Techstack/#nostr","title":"nostr","text":"<p>Nostr-mail builds on the <code>python-nostr==0.0.2</code>, which may be found here. </p>"},{"location":"Techstack/#secp256k1","title":"secp256k1","text":"<p>This library handles the PGP side of nostr-mail and is a dependency of <code>python-nostr</code>. It is maintained by rustyrussell and may be found here.</p>"},{"location":"Techstack/#workflow","title":"Workflow","text":""},{"location":"Techstack/#privpub-key-generation","title":"priv/pub key generation","text":"<p>If you don't already have a nostr private key, use this to generate one. </p> <pre><code>from nostr.key import PrivateKey\n\nprivate_key = PrivateKey()\npublic_key = private_key.public_key\nprint(f\"Private key: {private_key.bech32()}\")\nprint(f\"Public key: {public_key.bech32()}\")\n</code></pre> <p>Copy and paste the above private key into <code>.env</code> at the root of this repo.</p> <pre><code>NOSTR_PRIV_KEY=&lt;priv key here&gt;\n</code></pre> <p>When you run the <code>nostrmail</code> container, this key will be used as the default private key if the environment variable is set.</p> <pre><code>import os\n</code></pre> <pre><code>try:\n    priv_key = os.environ['NOSTR_PRIV_KEY']\nexcept KeyError:\n    raise KeyError('Please set environment variable NOSTR_PRIV_KEY')\n</code></pre>"},{"location":"Techstack/#connecting-to-proxies","title":"Connecting to proxies","text":"<p>The following code is borrowed from the <code>python-nostr==0.0.2</code> docs. No attempt has been made to optimize relay connections on our part. There are open issues on <code>python-nostr</code> that address this. </p> <pre><code>import json\nimport ssl\nimport time\nfrom nostr.relay_manager import RelayManager\n\nrelay_manager = RelayManager()\nrelay_manager.add_relay(\"wss://nostr-pub.wellorder.net\")\nrelay_manager.add_relay(\"wss://relay.damus.io\")\nrelay_manager.add_relay(\"wss://relay.oldcity-bitcoiners.info\")\nrelay_manager.open_connections({\"cert_reqs\": ssl.CERT_NONE}) # NOTE: This disables ssl certificate verification\ntime.sleep(1.25) # allow the connections to open\n\nwhile relay_manager.message_pool.has_notices():\n    notice_msg = relay_manager.message_pool.get_notice()\n    print(notice_msg.content)\n\nrelay_manager.close_connections()\n</code></pre>"},{"location":"Techstack/#text-events","title":"Text events","text":"<p>From NIP-01 there are three kinds of events</p> <ul> <li>0: set_metadata: the content is set to a stringified JSON object {name: , about: , picture: } describing the user who created the event. A relay may delete past set_metadata events once it gets a new one for the same pubkey. <li>1: text_note: the content is set to the plaintext content of a note (anything the user wants to say). Markdown links ( stuff) are not plaintext.</li> <li>2: recommend_server: the content is set to the URL (e.g., wss://somerelay.com) of a relay the event creator wants to recommend to its followers.</li> <pre><code>from nostrmail.utils import get_events\n</code></pre> <p>Let's view HelloJessica's nostr events.</p> <pre><code>node_hello = 'npub1k9tkawv6ga6ptz3jl30pjzh68hk5mgvl28al5zc6r0myy849wvaq38a70g'\nnode_hello_hex = 'b1576eb99a4774158a32fc5e190afa3ded4da19f51fbfa0b1a1bf6421ea5733a'\n</code></pre> <pre><code>text_hello = get_events(node_hello_hex, 'text')\ntext_hello\n</code></pre> <pre><code>meta_hello = get_events(node_hello_hex, 'meta')\nmeta_hello\n</code></pre>"},{"location":"Techstack/#shared-secret","title":"Shared secret","text":"<p>First we'll create two key pairs, one for the sender and one for the receiver</p> <pre><code>from nostr.key import PrivateKey\n\npriv_key1 = PrivateKey()\npub_key1 = priv_key1.public_key\nprint(f\"Private key: {priv_key1.bech32()}\")\nprint(f\"Public key: {pub_key1.bech32()}\")\n</code></pre> <pre><code>priv_key2 = PrivateKey()\npub_key2 = priv_key2.public_key\nprint(f\"Private key: {priv_key1.bech32()}\")\nprint(f\"Public key: {pub_key1.bech32()}\")\n</code></pre> <pre><code>assert priv_key1.compute_shared_secret(pub_key2.hex()) == priv_key2.compute_shared_secret(pub_key1.hex())\n\nprint('shared secret validated!')\n</code></pre>"},{"location":"Techstack/#encryption","title":"Encryption","text":"<p>nostr-python already uses AES 256 (?) encryption. More on the encryption scheme can be found here https://github.com/jeffthibault/python-nostr/blob/37cb66ba2d3968b2d75cc8ad71c3550415ca47fe/nostr/key.py#L69</p> <pre><code>from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport secrets\niv = secrets.token_bytes(16)\ncipher = Cipher(algorithms.AES(self.compute_shared_secret(public_key_hex)), modes.CBC(iv))\n</code></pre> <pre><code>help(priv_key1.encrypt_message)\n</code></pre> <pre><code>help(priv_key2.decrypt_message)\n</code></pre> <pre><code>clear_message = 'hello there'\n\nencrypted_msg = priv_key1.encrypt_message(clear_message, pub_key2.hex())\nencrypted_msg\n</code></pre> <pre><code>assert priv_key2.decrypt_message(encrypted_msg, pub_key1.hex()) == clear_message\n</code></pre> <p>This approach uses the key pairs alone. There is no timing information included.</p>"},{"location":"Techstack/#mock-email-flow","title":"Mock email flow","text":"<pre><code>sender_priv = PrivateKey()\nsender_pub = sender_priv.public_key.hex()\n\nemail_msg = \"\"\"\n    Well, hello there!\n\n    This is a decrypted message!\n\"\"\"\n\nreceiver_priv = PrivateKey()\nreceiver_pub = receiver_priv.public_key.hex()\n\nsender_secret = sender_priv.compute_shared_secret(receiver_pub)\nsender_secret # will match receiver secret\n</code></pre> <p><code>python-nostr/key.py</code></p> <pre><code>def compute_shared_secret(self, public_key_hex: str) -&gt; bytes:\n        pk = secp256k1.PublicKey(bytes.fromhex(\"02\" + public_key_hex), True)\n        return pk.ecdh(self.raw_secret, hashfn=copy_x)\n</code></pre> <p>The shared secret is the result of applying Elliptic Curve Diffie-Hellman, so it should return a point on the elliptic curve (which is just another public key)</p> <pre><code>sender_secret # can turn into hex encoded str\n</code></pre> <pre><code>encrypted_email = encrypt(email_msg, sender_secret)\nencrypted_email\n</code></pre> <pre><code>receiver_secret = receiver_priv.compute_shared_secret(sender_pub)\n\n# this works because the receiver_secret matches the sender_secret (hence, shared secret)\ndecrypted_email = decrypt(encrypted_email, receiver_secret)\nprint(decrypted_email)\n</code></pre>"},{"location":"Techstack/#try-connecting-to-damus","title":"Try connecting to Damus","text":"<pre><code>import json \nimport ssl\nimport time\nfrom nostr.event import Event\nfrom nostr.relay_manager import RelayManager\nfrom nostr.message_type import ClientMessageType\nfrom nostr.key import PrivateKey\n\nrelay_manager = RelayManager()\nrelay_manager.add_relay(\"wss://nostr-pub.wellorder.net\")\nrelay_manager.add_relay(\"wss://relay.damus.io\")\nrelay_manager.open_connections({\"cert_reqs\": ssl.CERT_NONE}) # NOTE: This disables ssl certificate verification\ntime.sleep(1.25) # allow the connections to open\n</code></pre> <pre><code>event = Event(pub_key_hex, \"Hello there\")\n</code></pre> <pre><code>priv_key.sign_event(event)\n</code></pre> <pre><code>assert event.verify() # checks signature on event\n</code></pre> <pre><code>relay_manager.publish_event(event)\ntime.sleep(1) # allow the messages to send\n\nrelay_manager.close_connections()\n</code></pre>"},{"location":"Techstack/#fetch-event-for-your-pub-key","title":"fetch event for your pub key","text":"<pre><code>from nostrmail.utils import get_events\n</code></pre> <pre><code>get_events(pub_key_hex)\n</code></pre> <pre><code>from nostr.key import mine_vanity_key\n</code></pre>"},{"location":"Techstack/#address-book","title":"Address book","text":"<pre><code>from omegaconf import OmegaConf\nimport pandas as pd\nimport dash_bootstrap_components as dbc\n</code></pre> <pre><code>from nostrmail.utils import load_contacts\n</code></pre> <pre><code>load_contacts()\n</code></pre> <pre><code>def update_contacts_table(url):\n    contacts = load_contacts()\n    table = dbc.Table.from_dataframe(contacts, index=True)\n    return table.children\n</code></pre>"},{"location":"Techstack/#create-user-profile","title":"create user profile","text":"<pre><code>try:\n    priv_key_str = os.environ['NOSTR_PRIV_KEY']\nexcept KeyError:\n    raise KeyError('Please set environment variable NOSTR_PRIV_KEY')\n</code></pre> <pre><code>priv_key = PrivateKey.from_nsec(priv_key_str)\nassert priv_key.bech32() == priv_key_str\n</code></pre> <pre><code>from nostrmail.utils import get_events, load_current_user\nfrom nostr.key import PrivateKey\nimport os\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Techstack/#generate-alice-profile","title":"Generate Alice profile","text":"<pre><code>import os\n</code></pre> <pre><code>from nostr.event import EventKind\nfrom nostr.key import PrivateKey\nfrom nostr.event import Event\nfrom nostr.relay_manager import RelayManager\nimport json\nimport ssl\n\nalice_priv_key_str = os.environ['PRIV_KEY_ALICE']\nalice_email = os.environ['EMAIL_ALICE']\nalice_priv_key = PrivateKey.from_nsec(alice_priv_key_str)\nassert alice_priv_key.bech32() == alice_priv_key_str\n</code></pre> <pre><code>import time\n</code></pre> <pre><code>from nostrmail.utils import relays, publish_profile\n</code></pre> <pre><code>alice_profile = dict(display_name='Alice',\n              name='alice',\n              picture='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTV-0rZbgnQcRbDqbk0hHPLHPyHpqLJ8xkriA&amp;usqp=CAU',\n              about='my name is Alice..',\n              email=alice_email)\n</code></pre> <pre><code>sig = publish_profile(alice_priv_key, alice_profile)\n</code></pre> <pre><code>sig\n</code></pre> <p>Verify that profile was published</p> <pre><code>from nostrmail.utils import get_events\n</code></pre> <pre><code>alice_profile_remote = get_events(alice_priv_key.public_key.hex(), 'meta')[0]\n</code></pre> <pre><code>assert alice_profile_remote['email'] == alice_email\n</code></pre> <pre><code>alice_profile_remote\n</code></pre>"},{"location":"Techstack/#publish-bobs-profile","title":"Publish Bob's profile","text":"<pre><code>bob_priv_key_str = os.environ['PRIV_KEY_BOB']\nbob_email = os.environ['EMAIL_BOB']\nbob_priv_key = PrivateKey.from_nsec(bob_priv_key_str)\nassert bob_priv_key.bech32() == bob_priv_key_str\n</code></pre> <pre><code>bob_priv_key.public_key.hex()\n</code></pre> <pre><code>bob_profile = dict(display_name='Bob',\n              name='bob',\n              picture='https://cdnb.artstation.com/p/assets/images/images/030/065/923/large/in-house-media-bobgundisplay.jpg?1599501909',\n              about=\"I am the one they call Bob\",\n              email=bob_email)\n</code></pre> <pre><code>sig = publish_profile(bob_priv_key, bob_profile)\n</code></pre> <pre><code>bob_profile_remote = get_events(bob_priv_key.public_key.hex(), 'meta')[0]\n</code></pre> <pre><code>assert bob_profile_remote['email'] == bob_email\n</code></pre> <pre><code>bob_profile_remote\n</code></pre> <pre><code>bob_priv_key.public_key.hex()\n</code></pre>"},{"location":"Techstack/#direct-message","title":"Direct Message","text":"<p>Test delivery of the email subject via dm. The standard is defined in https://github.com/nostr-protocol/nips/blob/master/04.md</p> <ul> <li>text is encrypted with <code>base64-encoded, aes-256-cbc</code> using the x-coordinate of the shared point between sender/receiver</li> <li>content includes an initialization vector <code>\"content\": \"&lt;encrypted_text&gt;?iv=&lt;initialization_vector&gt;\"</code></li> <li><code>tags</code> MUST contain an entry identifying the receiver of the message in the form <code>[\"p\", \"&lt;pubkey, as a hex string&gt;\"]</code>.</li> <li><code>tags</code> MAY contain an entry identifying the previous message in a conversation or a message we are explicitly replying to, in the form <code>[\"e\", \"&lt;event_id&gt;\"]</code>.</li> </ul> <pre><code>from nostr.key import PrivateKey\nimport os\nalice_priv_key_str = os.environ['PRIV_KEY_ALICE']\nalice_email = os.environ['EMAIL_ADDRESS_ALICE']\nalice_priv_key = PrivateKey.from_nsec(alice_priv_key_str)\nassert alice_priv_key.bech32() == alice_priv_key_str\n\nbob_priv_key_str = os.environ['PRIV_KEY_BOB']\nbob_email = os.environ['EMAIL_ADDRESS_BOB']\nbob_priv_key = PrivateKey.from_nsec(bob_priv_key_str)\nassert bob_priv_key.bech32() == bob_priv_key_str\n</code></pre> <p>Confirm that we can create a valid priv key from the one provided</p> <pre><code>from nostrmail.utils import relays, publish_direct_message\n</code></pre> <pre><code># publish_direct_message(alice_priv_key, bob_priv_key.public_key.hex(), \"hi ho bob!\")\n</code></pre> <pre><code>from nostrmail.utils import get_events\n</code></pre> <pre><code>txt_events = get_events(bob_priv_key.public_key.hex(), kind='dm', returns='event')\n</code></pre> <pre><code>for e in txt_events:\n    print(e.content, e.tags)\n</code></pre> <pre><code>bob_priv_key.public_key.hex()\n</code></pre> <pre><code>bob_priv_key.decrypt_message(e.content, alice_priv_key.public_key.hex())\n</code></pre> <pre><code># publish_direct_message(bob_priv_key, alice_priv_key.public_key.hex(), 'hullo, hullo!', e.id)\n</code></pre> <pre><code>from nostrmail.utils import get_dms, get_convs\n</code></pre> <pre><code>import pandas as pd\n</code></pre> <pre><code>alice_dms = get_dms(alice_priv_key.public_key.hex())\n</code></pre> <pre><code>alice_priv_key.public_key.hex()\n</code></pre> <pre><code>dms = pd.DataFrame(alice_dms)\ndms['conv'] = get_convs(dms)\n</code></pre> <pre><code>dms\n</code></pre> <pre><code>pd.DataFrame(alice_dms).set_index('time').sort_index(ascending=False)\n</code></pre> <pre><code>bob_dms = get_dms(bob_priv_key.public_key.hex())\n</code></pre> <pre><code>bob_dms_df = pd.DataFrame(bob_dms)\n</code></pre> <pre><code>bob_dms_df['convs'] = get_convs(bob_dms_df)\n</code></pre> <pre><code>bob_dms_df\n</code></pre> <pre><code>bob_dms\n</code></pre> <pre><code>def get_encryption_iv(msg):\n    \"\"\"extract the iv from an encrypted blob\"\"\"\n    return msg.split('?iv=')[-1].strip('==')\n</code></pre> <pre><code>for id_, _ in pd.DataFrame(bob_dms).iterrows():\n    print(get_encryption_iv(_.content), alice_priv_key.decrypt_message(_.content, bob_priv_key.public_key.hex()))\n</code></pre> <pre><code>alice_priv_key.decrypt_message(_.content, bob_priv_key.public_key.hex())\n</code></pre> <pre><code># from nostr.event import EncryptedDirectMessage # this isn't available as of nostr==0.0.2\n\n# dm = EncryptedDirectMessage(\n#   recipient_pubkey=recipient_pubkey,\n#   cleartext_content=\"Secret message!\"\n# )\n# private_key.sign_event(dm)\n# relay_manager.publish_event(dm)\n</code></pre>"},{"location":"Techstack/#contacts","title":"Contacts","text":"<p>There's a nip for contacts! https://github.com/nostr-protocol/nips/blob/master/02.md e.g. frank.david.erin </p>"},{"location":"Techstack/#search-email-by-subject","title":"search email by subject","text":"<pre><code>import imaplib\nimport email\n</code></pre> <pre><code>import os\n</code></pre> <pre><code>email_imap = os.environ['IMAP_HOST']\n</code></pre> <pre><code>email_username = os.environ['EMAIL_ADDRESS']\n</code></pre> <pre><code>email_password = os.environ['EMAIL_PASSWORD']\n</code></pre> <pre><code># Set up connection to IMAP server\nmail = imaplib.IMAP4_SSL(email_imap)\n</code></pre> <pre><code>if not email_is_logged_in(mail):\n    print('logging in')\n    mail.login(email_username, email_password)\n</code></pre> <pre><code>mail.login(email_username, email_password)\n</code></pre> <pre><code>email_is_logged_in(mail)\n</code></pre> <pre><code>if not email_is_logged_in(mail):\n    print('logging in')\n    mail.login(email_username, email_password)\n</code></pre> <pre><code>from dash import html\n</code></pre> <pre><code>mail.select('Inbox')\n</code></pre> <pre><code># email_body = find_email_by_subject(mail, 'bVpH/kND9hb1p83A0saXYw')\nemail_body = find_email_by_subject(mail, 'r2e7cDJR6dqDgShm6w')\n\nemail_body\n</code></pre> <pre><code>type(email_body)\n</code></pre> <pre><code>check_if_email_logged_in(mail)\n</code></pre> <pre><code>from dash import dcc\n</code></pre> <pre><code>dcc.Markdown?\n</code></pre> <pre><code>print(alice_priv_key.decrypt_message(email_body, bob_priv_key.public_key.hex()))\n</code></pre> <pre><code>imaplib.IMAP4_SSL?\n</code></pre> <pre><code># Close the mailbox and logout from the IMAP server\nmail.close()\nmail.logout()\n</code></pre> <pre><code>assert not email_is_logged_in(mail)\n</code></pre>"},{"location":"Techstack/#filters","title":"Filters","text":"<pre><code>from nostr.filter import Filter, Filters\n</code></pre> <pre><code>Filters?\n</code></pre> <pre><code>Filter?\n</code></pre> <pre><code>%load_ext autoreload\n%autoreload 2\n</code></pre>"},{"location":"Techstack/#block-height-caching","title":"Block height caching","text":"<p>We'll use block height to cache profile data.</p> <pre><code>from nostrmail.utils import get_block_hash, get_block_info, get_latest_block_hash\n</code></pre> <pre><code>block_hash = get_latest_block_hash()\n</code></pre> <pre><code>block_hash\n</code></pre> <pre><code>latest_block = get_block_info(block_hash=block_hash)\n</code></pre> <pre><code>latest_block['height']\n</code></pre> <pre><code>\n</code></pre>"},{"location":"WorkLog/","title":"WorkLog","text":"<p>This project uses hourly for labor accounting.</p>"},{"location":"WorkLog/#2023-04-29-011150217567-clock-out","title":"2023-04-29 01:11:50.217567: clock-out","text":"<ul> <li>documentation, presentation</li> </ul>"},{"location":"WorkLog/#2023-04-28-230624151223-clock-in","title":"2023-04-28 23:06:24.151223: clock-in","text":""},{"location":"WorkLog/#2023-04-28-180130320739-clock-out","title":"2023-04-28 18:01:30.320739: clock-out","text":"<ul> <li>packaging, discussion with Tadge</li> <li>Tadgh Drija on cc'ing: use a single encryption key and encrypt it to everyone's pub keys and include the whole decryption package in the message. This could be a json blob storing the following</li> </ul> <pre><code>scheme: aes256\nreceiver keys:\n- pub_key: encrypted decryption key\n- ...\n</code></pre>"},{"location":"WorkLog/#2023-04-28-175510766292-clock-in","title":"2023-04-28 17:55:10.766292: clock-in","text":""},{"location":"WorkLog/#2023-04-28-120540850929-clock-out","title":"2023-04-28 12:05:40.850929: clock-out","text":"<ul> <li>docs</li> </ul>"},{"location":"WorkLog/#2023-04-28-102811651768-clock-in","title":"2023-04-28 10:28:11.651768: clock-in","text":""},{"location":"WorkLog/#2023-04-23-150829738699-clock-out","title":"2023-04-23 15:08:29.738699: clock-out","text":"<ul> <li>handle imap connection error</li> </ul>"},{"location":"WorkLog/#2023-04-23-145312076305-clock-in","title":"2023-04-23 14:53:12.076305: clock-in","text":""},{"location":"WorkLog/#2023-04-23-101754445850-clock-out","title":"2023-04-23 10:17:54.445850: clock-out","text":"<ul> <li>caching improvements looking at session storage</li> </ul>"},{"location":"WorkLog/#2023-04-23-091940385017-clock-in","title":"2023-04-23 09:19:40.385017: clock-in","text":""},{"location":"WorkLog/#2023-04-19-234327964016-clock-out","title":"2023-04-19 23:43:27.964016: clock-out","text":"<ul> <li>improved loading times to avoid timeout</li> </ul>"},{"location":"WorkLog/#2023-04-19-230312254233-clock-in","title":"2023-04-19 23:03:12.254233: clock-in","text":""},{"location":"WorkLog/#2023-04-15-105738662251-clock-out","title":"2023-04-15 10:57:38.662251: clock-out","text":"<ul> <li>refreshing user profile</li> </ul>"},{"location":"WorkLog/#2023-04-15-095933579529-clock-in","title":"2023-04-15 09:59:33.579529: clock-in","text":""},{"location":"WorkLog/#2023-04-15-094901574530-clock-out","title":"2023-04-15 09:49:01.574530: clock-out","text":"<ul> <li>cache reset button</li> </ul>"},{"location":"WorkLog/#2023-04-15-091532803650-clock-in","title":"2023-04-15 09:15:32.803650: clock-in","text":""},{"location":"WorkLog/#2023-04-10-224809284772-clock-out","title":"2023-04-10 22:48:09.284772: clock-out","text":"<ul> <li>testing user container</li> </ul>"},{"location":"WorkLog/#2023-04-10-220543542150-clock-in","title":"2023-04-10 22:05:43.542150: clock-in","text":"<ul> <li>to sanize emails, check out amonia with nh3 python binding https://nh3.readthedocs.io/en/latest/</li> </ul>"},{"location":"WorkLog/#2023-04-09-235100895163-clock-out","title":"2023-04-09 23:51:00.895163: clock-out","text":"<ul> <li>update profile button</li> </ul>"},{"location":"WorkLog/#2023-04-09-220851287745-clock-in","title":"2023-04-09 22:08:51.287745: clock-in","text":""},{"location":"WorkLog/#2023-04-09-102557371034-clock-out","title":"2023-04-09 10:25:57.371034: clock-out","text":"<ul> <li>hot reload by env, edit user profile</li> </ul>"},{"location":"WorkLog/#2023-04-09-101108859105-clock-in","title":"2023-04-09 10:11:08.859105: clock-in","text":""},{"location":"WorkLog/#2023-04-08-191840274196-clock-out","title":"2023-04-08 19:18:40.274196: clock-out","text":"<ul> <li>documentation</li> </ul>"},{"location":"WorkLog/#2023-04-08-181251398424-clock-in","title":"2023-04-08 18:12:51.398424: clock-in","text":"<ul> <li>example env file</li> </ul>"},{"location":"WorkLog/#2023-04-08-134435437850-clock-out","title":"2023-04-08 13:44:35.437850: clock-out","text":"<ul> <li>got email working with dms</li> </ul>"},{"location":"WorkLog/#2023-04-08-104550749441-clock-in","title":"2023-04-08 10:45:50.749441: clock-in","text":""},{"location":"WorkLog/#2023-03-26-161400530769-clock-out","title":"2023-03-26 16:14:00.530769: clock-out","text":"<ul> <li>rendering avatars in inbox</li> </ul>"},{"location":"WorkLog/#2023-03-26-151745151187-clock-in","title":"2023-03-26 15:17:45.151187: clock-in","text":""},{"location":"WorkLog/#2023-03-21-141928772712-clock-out","title":"2023-03-21 14:19:28.772712: clock-out","text":"<ul> <li>conversations</li> </ul>"},{"location":"WorkLog/#2023-03-21-130606735484-clock-in","title":"2023-03-21 13:06:06.735484: clock-in","text":""},{"location":"WorkLog/#2023-03-20-190945883040-clock-out-t-10m","title":"2023-03-20 19:09:45.883040: clock-out: T-10m","text":"<ul> <li>update inbox, avatars</li> </ul>"},{"location":"WorkLog/#2023-03-20-181156948100-clock-in","title":"2023-03-20 18:11:56.948100: clock-in","text":""},{"location":"WorkLog/#2023-03-20-110501507585-clock-out","title":"2023-03-20 11:05:01.507585: clock-out","text":"<ul> <li>fetching dms</li> </ul>"},{"location":"WorkLog/#2023-03-20-101438822856-clock-in","title":"2023-03-20 10:14:38.822856: clock-in","text":""},{"location":"WorkLog/#2023-03-19-234545312979-clock-out","title":"2023-03-19 23:45:45.312979: clock-out","text":""},{"location":"WorkLog/#2023-03-19-223839007652-clock-in","title":"2023-03-19 22:38:39.007652: clock-in","text":""},{"location":"WorkLog/#2023-03-19-213820532966-clock-out","title":"2023-03-19 21:38:20.532966: clock-out","text":"<ul> <li>setting up dms</li> </ul>"},{"location":"WorkLog/#2023-03-19-211030939365-clock-in","title":"2023-03-19 21:10:30.939365: clock-in","text":""},{"location":"WorkLog/#2023-03-19-020402230490-clock-out","title":"2023-03-19 02:04:02.230490: clock-out","text":"<ul> <li>email send</li> </ul>"},{"location":"WorkLog/#2023-03-18-233936131727-clock-in","title":"2023-03-18 23:39:36.131727: clock-in","text":"<ul> <li>ignoring env</li> </ul>"},{"location":"WorkLog/#2023-03-18-220731239372-clock-out","title":"2023-03-18 22:07:31.239372: clock-out","text":"<ul> <li>encrypting subject and body to receiver</li> </ul>"},{"location":"WorkLog/#2023-03-18-202313413597-clock-in","title":"2023-03-18 20:23:13.413597: clock-in","text":""},{"location":"WorkLog/#2023-03-18-185629590170-clock-out","title":"2023-03-18 18:56:29.590170: clock-out","text":"<ul> <li>render user profile, credentials</li> </ul>"},{"location":"WorkLog/#2023-03-18-174322541161-clock-in","title":"2023-03-18 17:43:22.541161: clock-in","text":""},{"location":"WorkLog/#2023-03-17-222616589981-clock-out-t-30m","title":"2023-03-17 22:26:16.589981: clock-out: T-30m","text":"<ul> <li>alice, bob services</li> </ul>"},{"location":"WorkLog/#2023-03-17-210816620064-clock-in","title":"2023-03-17 21:08:16.620064: clock-in","text":""},{"location":"WorkLog/#2023-03-12-221603525915-clock-out","title":"2023-03-12 22:16:03.525915: clock-out","text":"<ul> <li>fetching email, profile pics</li> </ul>"},{"location":"WorkLog/#2023-03-12-212832683363-clock-in","title":"2023-03-12 21:28:32.683363: clock-in","text":""},{"location":"WorkLog/#2023-03-12-190752308489-clock-out","title":"2023-03-12 19:07:52.308489: clock-out","text":"<ul> <li>imap receiver</li> </ul>"},{"location":"WorkLog/#2023-03-12-185217463282-clock-in","title":"2023-03-12 18:52:17.463282: clock-in","text":""},{"location":"WorkLog/#2023-03-11-223758222838-clock-out","title":"2023-03-11 22:37:58.222838: clock-out","text":"<ul> <li>publish alice and bob profiles</li> </ul>"},{"location":"WorkLog/#2023-03-11-220811340599-clock-in","title":"2023-03-11 22:08:11.340599: clock-in","text":""},{"location":"WorkLog/#2023-03-11-204025042590-clock-out","title":"2023-03-11 20:40:25.042590: clock-out","text":"<ul> <li>alice and bob keys</li> </ul>"},{"location":"WorkLog/#2023-03-11-194755859711-clock-in","title":"2023-03-11 19:47:55.859711: clock-in","text":""},{"location":"WorkLog/#2023-03-11-175930794963-clock-out","title":"2023-03-11 17:59:30.794963: clock-out","text":"<ul> <li>rendering contacts profile</li> </ul>"},{"location":"WorkLog/#2023-03-11-153757782640-clock-in","title":"2023-03-11 15:37:57.782640: clock-in","text":""},{"location":"WorkLog/#2023-03-11-144505108228-clock-out","title":"2023-03-11 14:45:05.108228: clock-out","text":"<ul> <li>switch from Fernet to nostr encryption scheme</li> </ul>"},{"location":"WorkLog/#2023-03-11-132819085627-clock-in","title":"2023-03-11 13:28:19.085627: clock-in","text":""},{"location":"WorkLog/#2023-03-05-200743617401-clock-out","title":"2023-03-05 20:07:43.617401: clock-out","text":"<ul> <li>setting up container priv keys</li> </ul>"},{"location":"WorkLog/#2023-03-05-191313083170-clock-in","title":"2023-03-05 19:13:13.083170: clock-in","text":""},{"location":"WorkLog/#2023-03-01-205356066092-clock-out","title":"2023-03-01 20:53:56.066092: clock-out","text":"<ul> <li>adding credentials, settings</li> <li>sidebar example https://dash-bootstrap-components.opensource.faculty.ai/examples/simple-sidebar/</li> <li>configuring smtp https://red-mail.readthedocs.io/en/stable/tutorials/client.html#config-smtp</li> </ul>"},{"location":"WorkLog/#2023-03-01-191217414119-clock-in","title":"2023-03-01 19:12:17.414119: clock-in","text":""},{"location":"WorkLog/#2023-02-27-183014616845-clock-out","title":"2023-02-27 18:30:14.616845: clock-out","text":"<ul> <li>reading email in python https://www.thepythoncode.com/article/reading-emails-in-python</li> </ul>"},{"location":"WorkLog/#2023-02-27-182434923804-clock-in","title":"2023-02-27 18:24:34.923804: clock-in","text":""},{"location":"WorkLog/#2023-02-26-215620776792-clock-out","title":"2023-02-26 21:56:20.776792: clock-out","text":"<ul> <li>installable package, basic email gui</li> </ul>"},{"location":"WorkLog/#2023-02-26-204138192299-clock-in","title":"2023-02-26 20:41:38.192299: clock-in","text":""},{"location":"WorkLog/#2023-02-25-132956840093-clock-out","title":"2023-02-25 13:29:56.840093: clock-out","text":"<ul> <li>working symmetric TOTP encryption</li> </ul>"},{"location":"WorkLog/#2023-02-25-115502107526-clock-in","title":"2023-02-25 11:55:02.107526: clock-in","text":""},{"location":"WorkLog/#2023-02-25-113127280425-clock-out","title":"2023-02-25 11:31:27.280425: clock-out","text":"<ul> <li>nip05 p2p registry</li> </ul>"},{"location":"WorkLog/#2023-02-25-105424729659-clock-in","title":"2023-02-25 10:54:24.729659: clock-in","text":""},{"location":"WorkLog/#2023-02-16-162837548094-clock-out","title":"2023-02-16 16:28:37.548094: clock-out","text":"<ul> <li>set up dependencies, trying nostr queries</li> </ul>"},{"location":"WorkLog/#2023-02-16-143504909245-clock-in","title":"2023-02-16 14:35:04.909245: clock-in","text":""},{"location":"related_work/","title":"Related Work","text":"<p>Here's other directions we've looked at for potential use in nostr-mail.</p>"},{"location":"related_work/#nip-05","title":"NIP-05","text":"<p>Note</p> <p>This is not required by nostr-mail. This section is just kept for pedagogical purposes.</p> <p>nip-05 is a Pub key validation standard based on control over a domain. Most email users will not have their own servers, however, so nostr-mail clients should not require it.</p> <p>HelloJessica is nip05 compliant, so we should be able to make a get request to his server to verify his pub key.</p> <pre><code>from nostrmail.utils import validate_nip05\n</code></pre> <pre><code>validate_nip05(node_hello_hex) # returns the name of this user according to their .com\n</code></pre> <p>Hello Jessica's NIP-05 json actually includes several other names, so this doubles as a PGP registry. However, <code>nip-02</code> provides a similar solution to registration.</p>"},{"location":"related_work/#nip-02","title":"NIP-02","text":"<p>NIP-02 Supports contacts lists, comprised of pub keys, petnames, and preferred relays. Users may be found by walking through the network of contacts. This is desirable for nostr-mail, where we want to easily look up an email address through dot notation. For instance, an email to <code>carol.bob.alice</code> means <code>find carol in my contacts</code>, then <code>find bob in carol's contacts</code>, then <code>find alice in bob's contacts</code>.</p>"},{"location":"related_work/#fernet-encryption","title":"Fernet encryption","text":"<p>Note</p> <p>Nostr-mail does not use this method. We decided to use the same scheme as NOSTr DMs to reduce the workload on other implementations.</p> <p>We could have used Fernet encryption available from the cryptography package. Fernet encryption is a form of symmetric encryption, meaning the same key may be used to encrypt and decrypt a message.</p> <pre><code>from cryptography.fernet import Fernet, InvalidToken\nimport base64\n\ndef get_fernet(key):\n    if isinstance(key, str):\n        fernet_key = base64.urlsafe_b64encode(bytes(key.ljust(32).encode()))\n    else:\n        fernet_key = base64.urlsafe_b64encode(key)\n    return Fernet(fernet_key)\n\n\ndef encrypt(message, key):\n    f = get_fernet(key)\n    token = f.encrypt(message.encode())\n\n    encrypted_msg = token.decode('ascii')\n\n    return encrypted_msg\n\ndef decrypt(message, key):\n    f = get_fernet(key)\n    decrypted_msg = f.decrypt(message.encode()).decode('ascii')\n\n    return decrypted_msg\n</code></pre> <pre><code>decrypt(encrypt('hello world', 'yowzah'), 'yowzah')\n</code></pre> <p>While apparently simpler, there are a few drawbacks that make this untenable:</p> <ul> <li>There's no <code>iv</code> token as with AES, so you have to directly match the dm with the subject when looking up emails</li> <li>All nostr-mail clients would have to implement fernet encryption in addition to AES for dms</li> </ul>"},{"location":"related_work/#totp","title":"TOTP","text":"<p>We may use a different key for each message by concatenating the shared secret with a time stamp and hashing the result. This is known as a time-based one-time password (TOTP) and should already be familiar to anyone who has used google authenticator. The time used would be the time the email was sent. The epoch needs to be large enough for the mail servers to route the message.</p> <p>It might also help to use the latest block hash as the time stamp.</p> <p>This approach may provide some additional security benefit, such as mitigating replay attacks or preventing emails from being sent from the future or something.</p> <pre><code>from cryptography.hazmat.primitives import hashes\n</code></pre> <pre><code>def sha256(message):\n    digest = hashes.Hash(hashes.SHA256())\n    digest.update(message.encode())\n    digest.update(b\"123\")\n    return digest.finalize()\n</code></pre> <pre><code>import base64\nbase64.urlsafe_b64encode(sha256('hey')).decode('ascii')\n</code></pre> <pre><code>sha256('hey')\n</code></pre> <pre><code>def hash_concat(key, value):\n    \"\"\"concatenates a message with a value and returns the hash\n    key - a binary\n    \"\"\"\n    key_str = base64.urlsafe_b64encode(key).decode('ascii')\n    return sha256(key_str + str(value))\n</code></pre> <p>Using the most recent bitcoin block</p> <pre><code>latest_block_hash = '000000000000000000065a582c53ef20e5ae37b74844b31bfcbd82f4c515fdb2'\n</code></pre> <pre><code>epoch_value = latest_block_hash\nassert sender_secret == receiver_secret\n\nprint(decrypt(encrypt(email_msg,\n                      hash_concat(sender_secret, latest_block_hash)),\n              hash_concat(receiver_secret, epoch_value)) # \n    )\n</code></pre>"}]}